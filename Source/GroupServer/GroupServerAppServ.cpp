/* Generated by Together */

#include <iostream>
#include "GroupServerApp.h"
#include "GameCommon.h"
#include "CommFunc.h"
#include "DBConnect.h"
#include "Team.h"
#include <conformity.h>

// ��ʱ�˳����ƺ��л�
//#define CHAEXIT_ONTIME

LoginManageList::LoginManageList()
{
    InitializeCriticalSection(&m_cs);
}

LoginManageList::~LoginManageList()
{
    DeleteCriticalSection(&m_cs);
}

bool LoginManageList::Insert(const std::string& name)
{
    bool ret = false;
    Lock();
    if(!_Query(name))
    {
        m_list.push_back(name);
        ret = true;
    }
    UnLock();
    return ret;
}

bool LoginManageList::Remove(const std::string& name)
{
    bool ret = false;
    LoginNameList::iterator it;
    Lock();
    for(it = m_list.begin(); it != m_list.end(); it++)
    {
        if((*it) == name)
        {
            ret = true;
            m_list.erase(it);
            break;
        }
    }
    UnLock();
    return ret;
}

bool LoginManageList::Query(const std::string& name)
{
    bool ret = false;
    Lock();

	ret = _Query(name);

    UnLock();
	return ret;
}

bool LoginManageList::_Query(const std::string& name)
{
    bool ret = false;
    LoginNameList::iterator it;

	for(it = m_list.begin(); it != m_list.end(); it++)
    {
        if((*it) == name)
        {
            ret = true;
            break;
        }
    }

	return ret;
}

void LoginManageList::Lock()
{
    EnterCriticalSection(&m_cs);
}

void LoginManageList::UnLock()
{
    LeaveCriticalSection(&m_cs);
}

bool GroupServerApp::OnConnect(DataSocket *datasock)					//����ֵ:true-��������,false-����������
{
	datasock->SetRecvBuf(64*1024);
	datasock->SetSendBuf(64*1024);
	if(!datasock->IsServer())
	{
		LogLine	l_line(g_LogConnect);
		//l_line<<newln<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"���ˣ�Socket��:"
		//	<<GetSockTotal()+1<<endln;
		l_line<<newln<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"come ! Socket num:"
			<<GetSockTotal()+1<<endln;
		//std::cout<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"���ˣ�Socket��:"<<GetSockTotal()+1<<std::endl;
		std::cout<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"come ! Socket num:"<<GetSockTotal()+1<<std::endl;
	}else
	{
		LogLine	l_line(g_LogConnect);
		/*
		l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"���ˣ�Socket��:"
			<<GetSockTotal()+1<<endln;
		*/
		l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"come ! Socket num:"
			<<GetSockTotal()+1<<endln;
		//std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"���ˣ�Socket��:"<<GetSockTotal()+1<<std::endl;
		std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"come ! Socket num:"<<GetSockTotal()+1<<std::endl;
	}
	return true;
}

void GroupServerApp::OnDisconnect(DataSocket *datasock,int reason)
{
	if(!datasock->IsServer())
	{
		m_mtxlogin.lock();
		try{
			if(g_gpsvr->m_acctsock	==datasock)
			{	
				g_gpsvr->m_acctsock	=0;
			}
		}catch(...){}
		m_mtxlogin.unlock();
		LogLine	l_line(g_LogConnect);
		/*
		l_line<<newln<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"���ˣ�Socket��:"
			<<GetSockTotal()<<"reason=("<<reason<<")"<<GetDisconnectErrText(reason)
			<<endln;
		*/
		l_line<<newln<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"go ! Socket num:"
			<<GetSockTotal()<<"reason=("<<reason<<")"<<GetDisconnectErrText(reason)
			<<endln;
		//std::cout<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"���ˣ�Socket��:"<<GetSockTotal()<<"reason="<<GetDisconnectErrText(reason).c_str()<<std::endl;
		std::cout<<"AccountServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"go ! Socket num:"<<GetSockTotal()<<"reason="<<GetDisconnectErrText(reason).c_str()<<std::endl;

		if(reason ==DS_SHUTDOWN || reason ==DS_DISCONN){return;}

		//std::cout<<"5���Ӻ��ٴ�����......"<<std::endl;
		std::cout<<"after 5 seconds reconnect......"<<std::endl;
		Sleep(5000);
		InitACTSvrConnect(*g_gpsvr);
	}else
	{
		GateServer	*l_gate	=(GateServer*)datasock->GetPointer();
		if(l_gate)
		{
			m_mtxlogin.lock();
			try{
				l_gate->SetDataSock(0);
			}catch(...){}
			m_mtxlogin.unlock();
			LogLine	l_line(g_LogConnect);
			/*
			l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"���ˣ�Socket��:"
			<<GetSockTotal()<<"reason=("<<reason<<")"<<GetDisconnectErrText(reason)
			<<endln;
			*/
			l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"go ! Socket num:"
				<<GetSockTotal()<<"reason=("<<reason<<")"<<GetDisconnectErrText(reason)
				<<endln;
			//std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"���ˣ�Socket��:"<<GetSockTotal()<<"reason="<<GetDisconnectErrText(reason).c_str()<<std::endl;
			std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"go ! Socket num:"<<GetSockTotal()<<"reason="<<GetDisconnectErrText(reason).c_str()<<std::endl;

			Player	*l_ply	=0;
			RunChainGetArmor<Player> l(m_plylst);
			while(l_ply =m_plylst.GetNextItem())
			{
				if(l_ply->m_gate ==l_gate)
				{
					RPacket	l_rpk;
					TP_USER_LOGOUT(l_ply,datasock,l_rpk);
				}
			}
			l.unlock();
		}
	}
}

WPacket	GroupServerApp::OnServeCall(DataSocket *datasock,RPacket &pk)
{
	uShort l_cmd	=pk.ReadCmd();
	switch (l_cmd)
	{
	case CMD_TP_LOGIN:		return TP_LOGIN(datasock,pk);
	case CMD_TP_USER_LOGIN:	return TP_USER_LOGIN(datasock,pk);
	case CMD_TP_REQPLYLST:	return TP_REQPLYLST(datasock,pk);	
	//NOTE: Missing default case...
	}

	Player	*	l_ply	=reinterpret_cast<Player *>(MakePointer(pk.ReverseReadLongLong()));
	unsigned long long		l_gtaddr=pk.ReverseReadLongLong();
	unsigned long long l_plygt	= 0;
	try
	{
		l_plygt	=l_ply->m_gtAddr;
	}catch(...)
	{
		l_ply	=0;
	}
	if(!l_ply || l_gtaddr !=l_plygt)
	{
		WPacket	l_retpk	=GetWPacket();
		l_retpk.WriteShort(ERR_PT_KICKUSER);
		return l_retpk;
	}
	switch (l_cmd)
	{
	case CMD_TP_USER_LOGOUT:return TP_USER_LOGOUT(l_ply,datasock,pk);
	case CMD_TP_BGNPLAY:	return TP_BGNPLAY(l_ply,datasock,pk);
	case CMD_TP_ENDPLAY:	return TP_ENDPLAY(l_ply,datasock,pk);
	case CMD_TP_NEWCHA:		return TP_NEWCHA(l_ply,datasock,pk);
	case CMD_TP_DELCHA:		return TP_DELCHA(l_ply,datasock,pk);
	case CMD_TP_CREATE_PASSWORD2: return TP_CREATE_PASSWORD2(l_ply,datasock,pk);
	case CMD_TP_UPDATE_PASSWORD2: return TP_UPDATE_PASSWORD2(l_ply,datasock,pk);
	}
	return 0;
}

void GroupServerApp::OnProcessData(DataSocket *datasock,RPacket &recvbuf)
{
	try
	{
		uShort l_cmd	=recvbuf.ReadCmd();
		switch (l_cmd)
		{
		case CMD_AP_KICKUSER:
			recvbuf.ReadShort();
			AP_KICKUSER(datasock,recvbuf);
			return;
		case CMD_TP_DISC:
			TP_DISC(datasock,recvbuf);
			return;
		case CMD_TP_ESTOPUSER_CHECK: 
			TP_ESTOPUSER_CHECK(datasock, recvbuf);
			return;
		case CMD_MP_GUILD_CHALL_PRIZEMONEY:
			MP_GUILD_CHALL_PRIZEMONEY( NULL, datasock, recvbuf );
			return;
		case CMD_MP_GM1SAY1://Add by sunny.sun 20080804			
			CP_GM1SAY1(NULL,datasock,recvbuf);
			return;
		case CMD_MP_GM1SAY:
			CP_GM1SAY( NULL, datasock, recvbuf);
			return;
		}
		Player	*	l_ply	=reinterpret_cast<Player *>(MakePointer(recvbuf.ReverseReadLongLong()));
		unsigned long long		l_gtaddr=recvbuf.ReverseReadLongLong();
		try{
			if(!l_ply || (l_cmd !=CMD_MP_ENTERMAP &&l_ply->m_currcha <0) || l_gtaddr !=l_ply->m_gtAddr)
			{
				//std::cout<<"l_cmd ="<<l_cmd<<"\tl_ply ="<<MakeULong(l_ply)<<"\tl_gtaddr ="<<l_gtaddr<<std::endl;
				//if(l_ply)
				//{
				//	std::cout<<"l_ply->m_currcha ="<<l_ply->m_currcha<<std::endl;
				//	std::cout<<"l_ply->m_gtAddr ="<<l_ply->m_gtAddr<<std::endl;
				//}
				
				KickUser(datasock,MakeULong(l_ply),l_gtaddr);
				return;
			}
		}catch(...)
		{
			//std::cout<<"exception"<<std::endl;
			KickUser(datasock,MakeULong(l_ply),l_gtaddr);
			return;
		}
		switch (l_cmd)
		{
		case CMD_CP_PING:
			CP_PING(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_REPORT_WG:
			CP_REPORT_WG(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_MOTTO:
			MP_GUILD_MOTTO(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_CHALLMONEY:
			MP_GUILD_CHALLMONEY( l_ply, datasock, recvbuf );
			return;
		case CMD_MP_GUILD_DISBAND:
			MP_GUILD_DISBAND(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_LEAVE:
			MP_GUILD_LEAVE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_KICK:
			MP_GUILD_KICK(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_CREATE:
			MP_GUILD_CREATE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GUILD_APPROVE:
			MP_GUILD_APPROVE(l_ply,datasock,recvbuf);
			return;
		//Add by sunny.sun 20090604
		case CMD_CP_GUILD_INVITE:
			CP_GUILD_INVITE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_GUILD_ACCEPT:
			CP_GUILD_ACCEPT(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_GUILD_REFUSE:
			CP_GUILD_REFUSE(l_ply,datasock,recvbuf);
			return;
		//end
		case CMD_MP_SAY2ALL:
			MP_SAY2ALL(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_SAY2TRADE:
			MP_SAY2TRADE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_REFUSETOME:
			CP_REFUSETOME(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_GM1SAY:
			CP_GM1SAY(l_ply,datasock,recvbuf);
			return;
#ifdef MANAGE_VER
		case CMD_CP_GMSAY:
			CP_GMSAY(l_ply,datasock,recvbuf);
			return;
#endif
		case CMD_CP_GM1SAY1://Add by sunny.sun 20080804			
			CP_GM1SAY1(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2TRADE:
			CP_SAY2TRADE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2ALL:
			CP_SAY2ALL(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2YOU:
			CP_SAY2YOU(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2TEM:
			CP_SAY2TEM(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SAY2GUD:
			CP_SAY2GUD(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_INVITE:
			CP_TEAM_INVITE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_ACCEPT:
			CP_TEAM_ACCEPT(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_REFUSE:
			CP_TEAM_REFUSE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_LEAVE:
			CP_TEAM_LEAVE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_TEAM_KICK:
			CP_TEAM_KICK(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_TEAM_CREATE:
			MP_TEAM_CREATE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_ENTERMAP:
			MP_ENTERMAP(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_MASTER_CREATE:
			MP_MASTER_CREATE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_MASTER_DEL:
			MP_MASTER_DEL(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_MASTER_FINISH:
			MP_MASTER_FINISH(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_MASTER_REFRESH_INFO:
			CP_MASTER_REFRESH_INFO(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_PRENTICE_REFRESH_INFO:
			CP_PRENTICE_REFRESH_INFO(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_INVITE:
			CP_FRND_INVITE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_ACCEPT:
			CP_FRND_ACCEPT(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_REFUSE:
			CP_FRND_REFUSE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_DELETE:
			CP_FRND_DELETE(l_ply,datasock,recvbuf);
			return;
			// Add by lark.li 20080804 begin
		case CMD_CP_FRND_DEL_GROUP:
			CP_FRND_DEL_GROUP(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_ADD_GROUP:
			CP_FRND_ADD_GROUP(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_MOVE_GROUP:
			CP_FRND_MOVE_GROUP(l_ply,datasock,recvbuf);
			return;
			// End
		case CMD_CP_FRND_CHANGE_GROUP:
			CP_FRND_CHANGE_GROUP(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_FRND_REFRESH_INFO:
			CP_FRND_REFRESH_INFO(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_CHANGE_PERSONINFO:
			CP_CHANGE_PERSONINFO(l_ply,datasock,recvbuf);
			return;
			// Add by lark.li 20080808 begin
		case CMD_CP_QUERY_PERSONINFO:
			CP_QUERY_PERSONINFO(l_ply,datasock,recvbuf);
			// End
		case CMD_CP_SESS_CREATE:
			CP_SESS_CREATE(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SESS_SAY:
			CP_SESS_SAY(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SESS_ADD:
			CP_SESS_ADD(l_ply,datasock,recvbuf);
			return;
		case CMD_CP_SESS_LEAVE:
			CP_SESS_LEAVE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GARNER2_CGETORDER:
			CP_GARNER2_GETORDER(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GARNER2_UPDATE://�����������������µ�����
			MP_GARNER2_UPDATE(l_ply,datasock,recvbuf);
			return;
		case CMD_MP_GMBANACCOUNT:
			MP_GM_BANACCOUNT(l_ply,datasock,recvbuf);
			return;
		}
	}catch(...)
	{
		return;
	}

}

void GroupServerApp::CP_PING(Player *ply,DataSocket *datasock,RPacket	&pk)
{
	Player	*l_ply	=ply->m_pingply;
	if(!l_ply)	return;
	ply->m_pingply	=0;
	//l_ply->SendSysInfo(dstring("����������ҡ�")<<ply->m_chaname[ply->m_currcha].c_str()<<"����pingֵΪ:"<<pk.ReadLong()<<"����");
	char l_buf[256];
	//sprintf(l_buf,RES_STRING(GP_GROUPSERVERAPPMASTER_CPP_00001),ply->m_chaname[ply->m_currcha].c_str(), pk.ReadLong());
	_snprintf_s(l_buf,sizeof(l_buf),_TRUNCATE,RES_STRING(GP_GROUPSERVERAPPMASTER_CPP_00001),ply->m_chaname[ply->m_currcha].c_str(), pk.ReadLong());
	l_ply->SendSysInfo(l_buf);
}

void GroupServerApp::CP_REPORT_WG(Player *ply,DataSocket *datasock,RPacket &pk)
{
	// ͳ�����ʹ���������
	if( !ply->m_bWG )
	{
		ply->m_bWG = TRUE;
		m_curWGChaNum++;
	}
	//ply->SendSysInfo( "�����˽�ɫʹ����ң�" );
}

void GroupServerApp::KickUser(DataSocket *datasock,unsigned long long gpaddr,unsigned long long gtaddr)
{
	WPacket l_wpk	=GetWPacket();
	l_wpk.WriteCmd(CMD_PT_KICKUSER);
	l_wpk.WriteLongLong(gpaddr);
	l_wpk.WriteLongLong(gtaddr);
	l_wpk.WriteShort(1);
	SendData(datasock,l_wpk);
}

WPacket	GroupServerApp::TP_LOGIN(DataSocket *datasock,RPacket &pk)
{
	WPacket	l_retpk			=GetWPacket();
	if(pk.ReadShort() !=atoi(m_cfg["Main"]["Version"]))
	{
		l_retpk.WriteShort(ERR_PT_LOGFAIL);
		Disconnect(datasock,100,-15);
		return l_retpk;
	}
	cChar		*l_gatename	=pk.ReadString();
	LogLine	l_line(g_LogConnect);
	l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<< "TP_LOGIN1" <<endln;

	m_mtxlogin.lock();
	l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<< "TP_LOGIN2" <<endln;

	try{
		GateServer	*l_gate		=FindGateSByName(l_gatename);
		if(l_gate)
		{
			if(l_gate->SetDataSock(datasock))
			{
				// Add by lark.li 20081119 begin
				l_gate->SetSync();
				// End
	
				l_retpk.WriteShort(ERR_SUCCESS);
				std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"re login success!"<<std::endl;
			}else
			{
				l_retpk.WriteShort(ERR_PT_SAMEGATENAME);
				std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"login failed: exsit the same name's GateServer "<<std::endl;
				Disconnect(datasock);
			}
		}else if(m_gatenum <GATE_MAX)
		{
			// Add by lark.li 20081119 begin
			m_gate[m_gatenum].SetSync();
			// End

			l_retpk.WriteShort(ERR_SUCCESS);
			m_gate[m_gatenum].m_name	=l_gatename;
			m_gate[m_gatenum].SetDataSock(datasock);
			m_gatenum ++;
			std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"login success"<<std::endl;
		}else
		{
			l_retpk.WriteShort(ERR_PT_LOGFAIL);
			std::cout<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<<"login failed!"<<std::endl;
			Disconnect(datasock);
		}
	}catch(...){}
	m_mtxlogin.unlock();
	l_line<<newln<<"GateServer:"<<datasock->GetPeerIP()<<","<<datasock->GetPeerPort()<< "TP_LOGIN3" <<endln;

	return l_retpk;
}

WPacket	GroupServerApp::TP_REQPLYLST(DataSocket *datasock,RPacket &pk)
{
	GateServer *l_gate	=(GateServer *)datasock->GetPointer();
	if(!l_gate)
	{
		return 0;
	}
	WPacket	l_retpk	=GetWPacket();
	Player	*	l_ply;uShort l_plynum =0;
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply	=m_plylst.GetNextItem();l_ply;l_ply	=m_plylst.GetNextItem())
	{
		if(l_ply->m_gate !=l_gate || l_ply->m_currcha <0)continue;
		l_retpk.WriteLongLong(l_ply->m_gtAddr);
		l_retpk.WriteLong(l_ply->m_chaid[l_ply->m_currcha]);
		l_plynum	++;
	}
	l.unlock();
	l_retpk.WriteShort(l_plynum);
	return l_retpk;
}

bool GroupServerApp::GetCHAsFromDBByPlayer(Player *player,WPacket &wpk)
{
	MutexArmor l_lockDB(m_mtxDB);
	int l_row =0;
	if((l_row  =m_tblaccounts->FetchRowByActName(player->m_acctname.c_str()))==0)		//�¼����ʺ�
	{
		player->m_bNew = true;
		player->m_password.clear();
		// Modify by lark.li 20081111 begin 
		//if( !m_tblaccounts->InsertRow(player->m_acctLoginID,player->m_acctname.c_str(),"0") )
		if( !m_tblaccounts->InsertRow(player->m_acctLoginID,player->m_acctname.c_str(),"0", atoi(m_cfg["account"]["equal"]) == 1 ? true:false) )
			// End
			return false;
		if( !m_tblaccounts->FetchRowByActName(player->m_acctname.c_str()) )
			return false;
		player->m_acctid = m_tblaccounts->GetActID();
		wpk.WriteChar(0);							//��ɫ����
	}else if(l_row ==1)
	{
		player->m_bNew = false;
		player->m_acctid = m_tblaccounts->GetActID();
		player->m_password = m_tblaccounts->GetPassword();
		player->m_gm	 =m_tblaccounts->GetGM();
		std::string l_chaid[Player::emMaxCharacters];
		player->m_chanum =char(Util_ResolveTextLine(m_tblaccounts->GetChaIDs(),l_chaid,Player::emMaxCharacters,';'));		
		wpk.WriteChar(player->m_chanum);			//��ɫ����
		char i=0,j=0;
		for(i=0,j=0;j<player->m_chanum;i++,j++)
		{
			player->m_chaid[i]		=atoi(l_chaid[j].c_str());
			if(!player->m_chaid[i])
			{
				wpk.WriteChar(0);
				i--;
			}else
			{
				if((l_row =m_tblcharaters->FetchRowByChaID(player->m_chaid[i])) ==1)
				{
					char	*l_look	=const_cast<char*>(m_tblcharaters->GetLook());			//��ȡ�������
					LOOK	look;MemSet((char*)&look,0,sizeof(LOOK));
					try{
						Strin2LookData(&look,std::string(l_look));
					}catch(...)
					{
						LogLine l_line(g_LogGrpServer);
						//l_line<<newln<<"ö���ʺ�["<<player->m_acctname<<"]�Ľ�ɫ[ID:"<<player->m_chaid[i]<<"]ʱ����������ݽ����쳣��"<<endln;
						l_line<<newln<<"enum account ["<<player->m_acctname<<"]'s char[ID:"<<player->m_chaid[i]<<"] find appearance data exception."<<endln;
						wpk.WriteChar(0);
						i--;
						continue;
					}
					wpk.WriteChar(1);					//��־�����ɫ��������Ч��
					player->m_chaname[i]	=m_tblcharaters->GetChaName();
					player->m_motto[i]		=m_tblcharaters->GetMotto();
					player->m_icon[i]		=m_tblcharaters->GetIcon();
					player->m_guild[i]		=m_tblcharaters->GetGuildID();
					wpk.WriteString(m_tblcharaters->GetChaName());		//��ɫ��
					//g_GetJobName(atoi(m_tblcharaters->GetJob()));
					//wpk.WriteString(m_tblcharaters->GetJob());			//ְҵ
					wpk.WriteString(g_GetJobName(atoi(m_tblcharaters->GetJob())));//ְҵ���� Modify by sunny.sun 20090212
					wpk.WriteShort(m_tblcharaters->GetDegree());		//�ȼ�
					wpk.WriteSequence((char*)&look,sizeof(LOOK));
				}else
				{
					if(l_row ==0)
					{
						LogLine l_line(g_LogGrpServer);
						//l_line<<newln<<"ö���ʺ�["<<player->m_acctname<<"]�Ľ�ɫ[ID:"<<player->m_chaid[i]<<"]ʱ����character������û�з����Ǹ���ɫ������";
						l_line<<newln<<"enum account["<<player->m_acctname<<"]'s char[ID:"<<player->m_chaid[i]<<"] can't find data in table character.";
 					}else
					{
						LogLine l_line(g_LogGrpServer);
						//l_line<<newln<<"ö���ʺ�["<<player->m_acctname<<"]�Ľ�ɫ[ID:"<<player->m_chaid[i]<<"]ʱ�������ݿ��������";
						l_line<<newln<<"enum account["<<player->m_acctname<<"]'s char[ID:"<<player->m_chaid[i]<<"] databse exception.";
					}
					wpk.WriteChar(0);					//��־�����ɫ��������Ч��
					i--;
				}
			}
		}
		player->m_chanum	=i;
	}else
	{
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"ö���ʺ�["<<player->m_acctname<<"]�Ľ�ɫʱ����account�������ݿ��������";
		l_line<<newln<<"enum account["<<player->m_acctname<<"] operate table account failed";
	}
	return true;
}

WPacket	GroupServerApp::TP_USER_LOGIN(DataSocket *datasock,RPacket &pk)
{
	uLong	l_ulMilliseconds	=25*1000;
	uLong	l_tick	=GetTickCount()	-pk.GetTickCount();

	if(l_ulMilliseconds>l_tick)
	{
		l_ulMilliseconds =l_ulMilliseconds -l_tick;

		WPacket	l_retpk	=0;
		Player	*l_ply	=g_gpsvr->m_plyheap.Get();

		l_ply->m_gate	=(GateServer *)datasock->GetPointer();
		l_ply->m_gtAddr		=pk.ReverseReadLongLong();
		in_addr		l_ina;
		l_ina.S_un.S_addr	=pk.ReverseReadLong();
		//strcpy(l_ply->m_clientip,inet_ntoa(l_ina));
		strncpy_s(l_ply->m_clientip,sizeof(l_ply->m_clientip),inet_ntoa(l_ina),_TRUNCATE);
		// Discard ...??
		pk.DiscardLast(static_cast<uLong>(sizeof(uShort)));
		// Discard Gate Address
		pk.DiscardLast(4);

		// Read this stuff but ignore it, as the packet was duplicated.
		//@to-do: add ReverseReadSequence/ReverseReadString.
		uShort cipherlen;
		uShort ivlen;
		pk.ReadSequence(cipherlen);
		pk.ReadSequence(ivlen);

		uShort	l_len;
		//Add by sunny.sun 20081223
		string  szLocale = "";
		szLocale = pk.ReadString();

		cChar *l_passport = pk.ReadString(&l_len);
		if( !l_passport || strlen(l_passport) >= 64 )
		{
			l_ply->Free();
			l_retpk = GetWPacket();
			l_retpk.WriteCmd(ERR_PT_INERR);
			return l_retpk;
		}
		l_ply->m_passport = l_passport;

		cChar  *l_acctname	=pk.ReadString(&l_len);			//AcctName
		if(!l_acctname ||strlen(l_acctname) > 128)
		{
			l_ply->Free();
			l_retpk =GetWPacket();
			l_retpk.WriteShort(ERR_PT_INERR);
			return l_retpk;
		}
		//if(strchr(l_acctname,'\'') || !IsValidName(l_acctname,l_len))
		//{
		//	LogLine l_line(g_LogGrpServer);
		//	l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]��������������Ƿ��ĵ�����'�ַ������ܾ���¼";
		//	l_line<<endln;
		//	l_ply->Free();
		//	l_retpk =GetWPacket();
		//	l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		//	return l_retpk;
		//}
		if(m_plylst.GetTotal() >=const_cha.MaxLoginUsr)
		{
			l_ply->Free();
			l_retpk	=GetWPacket();
			l_retpk.WriteShort(ERR_MC_TOOMANYPLY);
			return l_retpk;
		}
		l_ply->m_acctname	=l_acctname;		

		// �������ᵼ�¼�ʹ���벻��ȷҲ���ߵ����
		// �����ʺ���֤��û�д���ʱ���ܵ�½
		//if(m_LoginList.Query(l_acctname))
		//{
		//          LG("AuthExcp", "Account %s multilogin at same times.1\n", l_acctname);
		//	
		//	KillUserByName(l_acctname);

		//	WPacket	l_retpk	=GetWPacket();
		//	l_retpk.WriteShort(ERR_AP_LOGGED);					//������

		//	return l_retpk;
		//}

		WPacket l_wpk	=pk;
		l_wpk.WriteCmd(CMD_PA_USER_LOGIN);
		RPacket	l_rpk	=SyncCall(m_acctsock,l_wpk,l_ulMilliseconds);	//��AccountServer��֤
		uShort	l_errno;
		if(!l_rpk.HasData())
		{
			l_retpk	=GetWPacket();
			l_retpk.WriteShort(ERR_PT_NETEXCP);					//������
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]��¼�������"<<endln;
			l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"] login net failed"<<endln;
			l_ply->Free();
		}else if((l_errno	=l_rpk.ReadShort()) && (l_rpk.ReadCmd() ==CMD_AP_KICKUSER))
		{
			AP_KICKUSER(datasock,RPacket(l_rpk));
			l_rpk.DiscardLast(sizeof(uLong));
			l_retpk	=	l_rpk;
		}else if(l_errno)
		{
			// Add by lark.li 20080825 begin
			l_retpk	=GetWPacket();
			l_retpk.WriteShort(l_errno);					//������
			l_retpk	=l_rpk;
			// End

			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]��¼������������:"<<l_errno<<endln;
			l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]login failed, error:"<<l_errno<<endln;
			l_ply->Free();
		}
		else
		{
			l_ply->m_acctLoginID =l_rpk.ReadLong();
			l_ply->m_sessid		=l_rpk.ReadLong();
			std::string sessionKey = l_rpk.ReadString();

			l_retpk	=GetWPacket();
			l_retpk.WriteShort(ERR_SUCCESS);			//�ɹ�����ֵ
			
			//Add by sunny.sun 20090205
			l_retpk.WriteString(sessionKey.c_str());
			
			GetCHAsFromDBByPlayer(l_ply,l_retpk);		//�������ݿ�ȡ��ɫ�б�

			if( l_ply->m_password.length() < 32 )
			{
				LogLine l_line(g_LogErrServer);
				//l_line<<newln<<"�ʻ�:"<<l_ply->m_acctname<<"ID:"<<l_ply->m_acctid<<"Key:("<<l_key<<")"<<"len"<<l_keylen<<"PW2:"<<l_ply->m_password<<endln;		
				l_line<<newln<<"account:"<<l_ply->m_acctname<<"ID:"<<l_ply->m_acctid<<"PW2:"<<l_ply->m_password<<endln;		
			}
			
			if( l_ply->m_password.length() > 0 && !l_ply->m_bNew)
			{
				l_retpk.WriteChar(1);				
			}
			else
			{
				l_retpk.WriteChar(0);
			}
			
			l_retpk.WriteLong(l_ply->m_acctid);
            l_retpk.WriteLong(l_ply->m_acctLoginID);
			l_retpk.WriteLongLong(MakeULong(l_ply));		//�������Լ��ĵ�ַ

			if(!m_LoginList.Insert(l_acctname))
			{
				LG("AuthExcp", "Account %s multilogin at same times.2\n", l_acctname);

				KillUserByName(l_acctname);

				WPacket	l_retpk	=GetWPacket();
				l_retpk.WriteShort(ERR_AP_LOGGED);					//������

				l_ply->Free();
				return l_retpk;
			}

			l_ply->BeginRun();

			//AddPlayerToList(l_ply->m_chaid[l_ply->m_currcha], l_ply);
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]��¼�ɹ���\t��ǰ��¼/��Ϸ�����:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;
			l_line<<newln<<"("<<l_ply->m_clientip<<"):["<<l_ply->m_acctname<<"]login success, \t nline/total:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;
		}
		return l_retpk;
	}else
	{
		WPacket	l_retpk	=GetWPacket();
		l_retpk.WriteShort(ERR_PT_NETEXCP);					//������
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"��֤���ڶ������ѳ�ʱ,ֱ�ӷ���,�������糬ʱ����."<<endln;
		l_line<<newln<<"authentication packet time out."<<endln;
		return l_retpk;
	}
}

void GroupServerApp::AP_KICKUSER2( DataSocket* datasock, uLong acctid )
{
	Player	*l_ply	=0;
	uLong l_acctid	=acctid;
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply =m_plylst.GetNextItem();l_ply;l_ply =m_plylst.GetNextItem())
	{
		if(l_ply->m_acctid ==l_acctid)
		{
			break;
		}
	}
	if(l_ply)
	{
		l_ply->EndPlay(datasock);
		if(l_ply->EndRun())
		{
			////��AccountServer����LogOut����
			WPacket l_wpk	=GetWPacket();
			//l_wpk.WriteCmd(CMD_PA_USER_LOGOUT);
			//l_wpk.WriteLong(l_ply->m_acctid);
			//l_wpk.WriteLong(l_ply->m_sessid);
			//SendData(m_acctsock,l_wpk);
			//��GateServer������������
			//l_wpk	=GetWPacket();
			l_wpk.WriteCmd(CMD_AP_KICKUSER);
			SendToClient(l_ply,l_wpk);

			//���˳ɹ�
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"�յ�һ��T��acctid/acctname:["<<l_acctid<<"]/["<<l_ply->m_acctname<<"]������!"<<endln;
			l_line<<newln<<"recieved killed acctid/acctname:["<<l_acctid<<"]/["<<l_ply->m_acctname<<"] command!"<<endln;
		}
		
		// ɾ���б�
		m_LoginList.Remove(l_ply->m_acctname);
		l_ply->Free();
	}else
	{
		l.unlock();
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"�յ�һ��T��������б���û�ҵ�acctid:["<<l_acctid<<"]������!";
		l_line<<newln<<"recieved kill acctid:["<<l_acctid<<"] command(not in play list)!";
	}
}

void GroupServerApp::KillUserByName(const char* accoutName)
{
	Player	*l_ply	=0;
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply =m_plylst.GetNextItem();l_ply;l_ply =m_plylst.GetNextItem())
	{
		if(strcmp(l_ply->m_acctname.c_str(),accoutName) == 0)
		{
			break;
		}
	}
	if(l_ply)
	{
		l_ply->EndPlay(NULL);
		{
			//��AccountServer����LogOut����
			WPacket l_wpk	=GetWPacket();
			l_wpk.WriteCmd(CMD_PA_USER_LOGOUT);
			l_wpk.WriteLong(l_ply->m_acctid);
			l_wpk.WriteLong(l_ply->m_sessid);
			SendData(m_acctsock,l_wpk);
			//��GateServer������������
			/*WPacket*/ l_wpk	=GetWPacket();
			l_wpk.WriteCmd(CMD_AP_KICKUSER);
			SendToClient(l_ply,l_wpk);
			//���˳ɹ�
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"�յ�һ��T��acctid/acctname:["<<l_ply->m_acctid<<"]/["<<l_ply->m_acctname<<"]������!"<<endln;
			l_line<<newln<<"recieved killed acctname:["<<l_ply->m_acctname<<"] command!"<<endln;
		}
		// ɾ���б�
		m_LoginList.Remove(l_ply->m_acctname);
		l_ply->Free();
	}else
	{
		l.unlock();
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"�յ�һ��T��������б���û�ҵ�acctid:["<<l_acctid<<"]������!";
		l_line<<newln<<"recieved kill acctname:["<<accoutName<<"] command(not in play list)!";
	}
}

void GroupServerApp::AP_KICKUSER(DataSocket *datasock,RPacket &pk)
{
	Player	*l_ply	=0;
	uLong l_acctid	=pk.ReadLong();
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply =m_plylst.GetNextItem();l_ply;l_ply =m_plylst.GetNextItem())
	{
		if(l_ply->m_acctLoginID ==l_acctid)
		{
			break;
		}
	}
	if(l_ply)
	{
		l_ply->EndPlay(datasock);
		if(l_ply->EndRun())
		{
			//��AccountServer����LogOut����
			WPacket l_wpk	=GetWPacket();
			l_wpk.WriteCmd(CMD_PA_USER_LOGOUT);
			l_wpk.WriteLong(l_ply->m_acctid);
			l_wpk.WriteLong(l_ply->m_sessid);
			SendData(m_acctsock,l_wpk);
			//��GateServer������������
			/*WPacket */l_wpk	=GetWPacket();
			l_wpk.WriteCmd(CMD_AP_KICKUSER);
			SendToClient(l_ply,l_wpk);
			//���˳ɹ�
			LogLine l_line(g_LogGrpServer);
			//l_line<<newln<<"�յ�һ��T��acctid/acctname:["<<l_ply->m_acctid<<"]/["<<l_ply->m_acctname<<"]������!"<<endln;
			l_line<<newln<<"recieved killed acctid/acctname:["<<l_ply->m_acctid<<"]/["<<l_ply->m_acctname<<"] command!"<<endln;
		}
		// ɾ���б�
		m_LoginList.Remove(l_ply->m_acctname);
		l_ply->Free();
	}else
	{
		l.unlock();
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"�յ�һ��T��������б���û�ҵ�acctid:["<<l_acctid<<"]������!";
		l_line<<newln<<"recieved kill acctid:["<<l_acctid<<"] command(not in play list)!";
	}
}

void GroupServerApp::TP_DISC(DataSocket *datasock,RPacket &pk)
{
	uLong	l_actid	=pk.ReadLong();
	in_addr		l_ina;
	l_ina.S_un.S_addr	=pk.ReadLong();
	cChar	*l_reason	=pk.ReadString();
	MutexArmor l_lockDB(m_mtxDB);
	m_tblaccounts->SetDiscInfo(l_actid,inet_ntoa(l_ina),l_reason);
	l_lockDB.unlock();
}

void GroupServerApp::TP_ESTOPUSER_CHECK(DataSocket *datasock,RPacket &pk)
{
	Player	*l_ply	=0;
	uLong l_acctid	=pk.ReadLong();
	RunChainGetArmor<Player> l(m_plylst);
	for(l_ply =m_plylst.GetNextItem();l_ply;l_ply =m_plylst.GetNextItem())
	{
		if(l_ply->m_acctid ==l_acctid)
		{
			break;
		}
	}
	if(l_ply)
	{
		l_ply->IsEstop();
	}
}

WPacket GroupServerApp::TP_USER_LOGOUT(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket	l_retpk	=GetWPacket();
	if(!ply || !ply->m_gtAddr)
	{
		l_retpk.WriteShort(ERR_PT_INERR);
		return l_retpk;
	}


	uLong	l_acctid	=ply->m_acctid;
	if(!l_acctid ||l_acctid !=ply->m_acctid)
	{
		l_retpk.WriteShort(ERR_PT_INERR);
		return l_retpk;
	}
	RunChainGetArmor<Player> l(m_plylst);

	if(ply->m_bCheat)
	{
		if(m_dwCheatCount > 0)
			m_dwCheatCount--;
	}

	ply->EndPlay(datasock);

	if(ply->EndRun())
	{
		//��AccountServer����LogOut����
		WPacket	l_wpk	=GetWPacket();
		l_wpk.WriteCmd(CMD_PA_USER_LOGOUT);
		l_wpk.WriteLong(ply->m_acctLoginID);
		l_wpk.WriteLong(ply->m_sessid);
		SendData(m_acctsock,l_wpk);
		//�ǳ��ɹ�
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]�ǳ��ˣ�\t��ǰ��¼/��Ϸ�����:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
		l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]logout,\t online/total:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
	}else
	{
		LogLine l_line(g_LogGrpServer);
		l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]logout,\t online/total:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
	}
	
	if( ply->m_bWG )
	{
		m_curWGChaNum--;
	}

	// ɾ���б�
	m_LoginList.Remove(ply->m_acctname);
	ply->Free();
	l.unlock();
	//���سɹ�������
	l_retpk.WriteShort(ERR_SUCCESS);
	return l_retpk;
}

WPacket	GroupServerApp::TP_BGNPLAY(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	if(ply->m_currcha >=0)
	{
		l_retpk.WriteShort(ERR_PT_INERR);				//Ӧ����ֵ���ڲ�����
	}else
	{
		uShort	l_len;
		cChar	*	l_cha	=pk.ReadString(&l_len);
		if(!l_cha ||l_len >common::conformity::character::name::max_length)
		{
			l_retpk.WriteShort(ERR_PT_INERR);				//Ӧ����ֵ���ڲ�����
		}else
		{
			MutexArmor l_lockCha(ply->m_mtxCha);
			ply->m_bp_currcha	=ply->FindIndexByChaName(l_cha);
			if(ply->m_bp_currcha <0)		//���ʺ�û�������ɫ
			{
				l_retpk.WriteShort(ERR_PT_INVALIDCHA);
			}
			else if( ply->m_password.length() <= 0 )
			{
				l_retpk.WriteShort(ERR_PT_INVALID_PW2);
			}
			else						//�Ϸ���ɫ
			{
				MutexArmor l_lockDB(m_mtxDB);
				if(m_tblcharaters->FetchRowByChaID(ply->m_chaid[ply->m_bp_currcha])<1)
				{
					l_retpk.WriteShort(ERR_PT_INERR);
				}else
				{
					int	l_maxval	=atoi(m_cfg["Database"]["MaxStatVal"]);
					if(l_maxval &&(m_tblcharaters->GetStr()>l_maxval ||m_tblcharaters->GetDex()>l_maxval
						||m_tblcharaters->GetAgi()>l_maxval ||m_tblcharaters->GetCon()>l_maxval
						||m_tblcharaters->GetSta()>l_maxval ||m_tblcharaters->GetLuk()>l_maxval))
					{
						l_retpk.WriteShort(ERR_PT_BADBOY);
						WPacket l_wpk	=GetWPacket();
						l_wpk.WriteCmd(CMD_MC_SYSINFO);
						//l_wpk.WriteString(dstring("��ͨ���������Ѿ�����һλBT����[�ʺ�:")<<ply->m_acctname.c_str()<<",��ɫ:"<< ply->m_chaname[ply->m_bp_currcha].c_str()<<"]��");
						char l_buf[256];
						//sprintf(l_buf,RES_STRING(GP_GROUPSERVERAPPSERV_CPP_00002),ply->m_acctname.c_str(),ply->m_chaname[ply->m_bp_currcha].c_str());
						//_snprintf_s(l_buf,sizeof(l_buf),_TRUNCATE,RES_STRING(GP_GROUPSERVERAPPSERV_CPP_00002),ply->m_acctname.c_str(),ply->m_chaname[ply->m_bp_currcha].c_str());
						CFormatParameter param(2);
						param.setString( 0, ply->m_acctname.c_str() );
						param.setString( 1, ply->m_chaname[ply->m_bp_currcha].c_str() );
						RES_FORMAT_STRING( GP_GROUPSERVERAPPSERV_CPP_00002, param, l_buf );
						l_wpk.WriteString(l_buf);

						Player *l_plylst[10240];
						short	l_plynum	=0;

						RunChainGetArmor<Player> l(m_plylst);
						for(Player	*l_plyr =m_plylst.GetNextItem();l_plyr;l_plyr =m_plylst.GetNextItem())
						{
							if(l_plyr->m_bp_currcha <0)continue;
							l_plylst[l_plynum]	=l_plyr;
							l_plynum++;
						}
						l.unlock();
						SendToClient(l_plylst,l_plynum,l_wpk);
						ply->m_currcha	=-1;
					}else
					{
						short swiner = 0;
						//���سɹ������Ϣ
						l_retpk.WriteShort(ERR_SUCCESS);	//ѡ��ɫ�ɹ�����
						l_retpk.WriteString(ply->m_password.c_str());
						l_retpk.WriteLong(ply->m_chaid[ply->m_bp_currcha]);//��ɫID
						l_retpk.WriteLong(ply->m_chaid[ply->m_bp_currcha]);//WorldID
						l_retpk.WriteString(m_tblcharaters->GetMap());		//�ϴ����ߵĵ�ͼ��
						for(int i = 0;i<MAXORDERNUM;i++)
						{
							if(ply->m_chaid[ply->m_bp_currcha] == m_tbLparam->GetOrderData(i)->nid)
							{
								swiner = i+1;
								break;
							}
						}
						l_retpk.WriteShort(swiner);
						LogLine l_line(g_LogGrpServer);
						/*
						l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]ѡ���ɫ["<<l_cha
							<<"]׼����ʼ��Ϸ��...��\t��ǰ��¼/��Ϸ�����:"<<m_plylst.GetTotal()<<"/"
							<<long(m_curChaNum);
						*/
						l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]select char["<<l_cha
							<<"]begin paly...��\t online/total:"<<m_plylst.GetTotal()<<"/"
							<<long(m_curChaNum);

					}
				}
				l_lockDB.unlock();
			}
			l_lockCha.unlock();
		}
	}
	return l_retpk;
}

WPacket GroupServerApp::TP_ENDPLAY(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	if(ply->m_currcha <0)
	{
		l_retpk.WriteShort(ERR_PT_INERR);				//Ӧ����ֵ��ϵͳ��һ�´���
	}else
	{
		l_retpk.WriteShort(ERR_SUCCESS);				//��ѡ��ɫ�ɹ�����
		ply->EndPlay(datasock);

		LogLine l_line(g_LogGrpServer);
		/*
		l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]�˳���ɫ["
			<<ply->m_chaname[ply->m_currcha]<<"]������ѡ��ɫ����...��\t��ǰ��¼/��Ϸ�����:"
			<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
		*/
		l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]exit char["
			<<ply->m_chaname[ply->m_currcha]<<"]begin entry select char UI...��\t online/total:"
			<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
		l_line<<endln;

		ply->m_currcha	=-1;						//��Ϊ��Ч�ĵ�ǰ��ɫ
		ply->EndPlayReset();

		//�����ݿ�����ȡ����ɫ��
		GetCHAsFromDBByPlayer(ply,l_retpk);
	}
	return l_retpk;
}

void GroupServerApp::MP_ENTERMAP(Player *ply,DataSocket *datasock,RPacket &pk)
{
	char		l_isSwitch;
	if(!(l_isSwitch	=pk.ReadChar()) && ply->m_currcha <0)
	{
		MP_ONLINE(ply);
	}else if(l_isSwitch && ply->m_currcha >=0)
	{
		MP_SWITCH(ply);
	}
}

void GroupServerApp::MP_ONLINE(Player *ply)
{
	MutexArmor l_lockDB(m_mtxDB);
	ply->m_currcha	=ply->m_bp_currcha;
	ply->m_bp_currcha	=-1;
	m_tblcharaters->SetAddr(ply->m_chaid[ply->m_currcha],MakeULong(ply));
	++m_curChaNum;
	LogLine l_line(g_LogGrpServer);
	/*
	l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]�Ľ�ɫ["
		<<ply->m_chaname[ply->m_currcha]<<"]�ɹ������ͼ��������ʼ��Ϸ��...��\t��ǰ��¼/��Ϸ�����:"
		<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
	*/
	l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"] char ["
		<<ply->m_chaname[ply->m_currcha]<<"]entry map server begin play...��\t online/total:"
		<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum);
	l_line<<endln;

	ply->CheckEstop();

	PC_FRND_INIT(ply);
	PC_GULD_INIT(ply);
	PC_MASTER_INIT(ply);
}

WPacket	GroupServerApp::TP_NEWCHA(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	if(ply->m_currcha >=0)
	{
		l_retpk.WriteShort(ERR_PT_INERR);					//Ӧ����ֵ��ϵͳ��һ�´���
		return l_retpk;
	}
	MutexArmor l_lockCha(ply->m_mtxCha);
	if(ply->m_chanum >=const_cha.MaxChaNum)		//�Ѵﵽϵͳ��������ɫ��
	{
		l_retpk.WriteShort(ERR_PT_TOMAXCHA);
	  return l_retpk;
	}

	uShort l_len;
	cChar* l_chaname = pk.ReadString(&l_len);
	if(!l_chaname)
	{
	  l_retpk.WriteShort(ERR_PT_INERR);
	  return l_retpk;
	}
	if(l_len > common::conformity::character::name::max_length)
	{
	  l_retpk.WriteShort(ERR_PT_TOOBIGCHANM);
	  return l_retpk;
	}
	
	if(!common::conformity::character::name::is_valid(l_chaname, l_len) ||
	   !CTextFilter::IsLegalText(CTextFilter::NAME_TABLE, l_chaname))
	{
	  l_retpk.WriteShort(ERR_PT_ERRCHANAME);
	  return l_retpk;
	}

	//cChar	*	l_birth			=pk.ReadString(&l_len);
	//dstring		l_birth1	="";
	//cChar	*	l_birth2		=0;
	//if(l_birth && l_len <30 && !strchr(l_birth,'/'))
	//{
	//	l_birth1	=dstring("/")<<l_birth<<"/";

	//	try{
	//		l_birth2		=this->m_cfg["��ɫ"]["������"];
	//	}catch(...)
	//	{
	//		l_birth2		=0;
	//	}
	//}else
	//{
	//	l_birth2	=0;
	//}
	//if(!l_birth2 ||!strstr(l_birth2,l_birth1))
	//{
	//	l_retpk.WriteShort(ERR_PT_INVALIDBIRTH);		//�����طǷ�
	//}else
	//{
	cChar	*	l_birth			=pk.ReadString(&l_len);
	dstring		l_birth1		="";
	cChar	*	l_map			=0;
	if(l_birth && l_len <30 && !strchr(l_birth,'/'))
	{
		l_birth1	=l_birth;
		try{
			// Modify by lark.li 20080702 begin
			//l_map	=m_cfg["������"][l_birth];
			//l_map	=m_cfg["birthplace"][l_birth];
			map<string, string>::iterator it = m_mapBirthplace.find(string(l_birth));

			if(it != m_mapBirthplace.end())
			{
				l_map = it->second.c_str();
			}

			// End
		}catch(...)
		{
			l_map	=0;
		}
	}else
	{
		l_map	=0;
	}
	if(!l_map)
	{
		l_retpk.WriteShort(ERR_PT_INVALIDBIRTH);		//�����طǷ�
		return l_retpk;
	}
	const LOOK	*look	=reinterpret_cast<const LOOK*>(pk.ReadSequence(l_len));
	if(!look || l_len !=sizeof(LOOK))
	{
		l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		return l_retpk;
	}
	char	l_look[defLOOK_DATA_STRING_LEN];
	try{
	if(!LookData2String(look,l_look,defLOOK_DATA_STRING_LEN))
	{
		l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		return l_retpk;
	}}catch(...)
	{
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"�ʺ�["<<ply->m_acctname<<"]�½���ɫ["<<l_chaname<<"]ʱ�����������ת���쳣��"<<endln;
		l_line<<newln<<"account["<<ply->m_acctname<<"]new char["<<l_chaname<<"]find appreance data convert exception"<<endln;
		l_retpk.WriteShort(ERR_PT_INVALIDDAT);
		return l_retpk;
	}
	MutexArmor l_lockDB(m_mtxDB);
	if(!m_tblcharaters->InsertRow(l_chaname,ply->m_acctid,l_birth,l_map,l_look))				//��ɫ���ظ�
	{
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"�ʺ�["<<ply->m_acctname<<"]�½���ɫ["<<l_chaname<<"]ʱ���������ظ���"<<endln;
		l_line<<newln<<"account["<<ply->m_acctname<<"]new char["<<l_chaname<<"]the same name exception"<<endln;
		l_retpk.WriteShort(ERR_PT_SAMECHANAME);
		return l_retpk;
	}
	l_retpk.WriteShort(ERR_SUCCESS);
	//�������ݿ����ʺŵĽ�ɫID�б�CharIDs
	if(m_tblcharaters->FetchRowByChaName(l_chaname) <1)
	{
		l_retpk.WriteShort(ERR_PT_INERR);
		LogLine l_line(g_LogGrpServer);
		//l_line<<newln<<"�ʺ�["<<ply->m_acctname<<"]�½���ɫʱ�������޷��ָ������ݿ��������";
		l_line<<newln<<"account["<<ply->m_acctname<<"] when create char , can't restore database failed.";
		return l_retpk;
	}
	ply->m_chaid[ply->m_chanum]		=m_tblcharaters->Getcha_id();
	ply->m_chaname[ply->m_chanum]	=l_chaname;
	ply->m_motto[ply->m_chanum]		=m_tblcharaters->GetMottonByName();
	ply->m_icon[ply->m_chanum]		=m_tblcharaters->GetIconByName();
	ply->m_guild[ply->m_chanum]		=0;
	ply->m_chanum	++;

	char	l_CharIDs[80];	l_CharIDs[0]=0;
	char	l_buf[20];
	for(char i=0;i<ply->m_chanum;i++)
	{
		//strcat(l_CharIDs,itoa(ply->m_chaid[i],l_buf,10));
		_itoa_s(ply->m_chaid[i],l_buf,sizeof(l_buf),10);
		strncat_s(l_CharIDs,sizeof(l_CharIDs),l_buf,_TRUNCATE);
		//strcat(l_CharIDs,";");
		strncat_s(l_CharIDs,sizeof(l_CharIDs),";",_TRUNCATE);
	}
	m_tblaccounts->UpdateRow(ply->m_acctid,l_CharIDs);
	l_lockDB.unlock();
	LogLine l_line(g_LogGrpServer);
	/*
	l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]�½��˽�ɫ["
		<<l_chaname<<"]��\t��ǰ��¼/��Ϸ�����:"
		<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;
	*/
	l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]create char ["
		<<l_chaname<<"]��\t online/total:"
		<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)<<endln;
	l_lockCha.unlock();
	return l_retpk;
}

WPacket	GroupServerApp::TP_DELCHA(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	if(ply->m_currcha >=0)
	{
		l_retpk.WriteShort(ERR_PT_INERR);					//Ӧ����ֵ��ϵͳ��һ�´���
	}else
	{
		uShort	l_len, l_len2;
		cChar	*	l_cha	=pk.ReadString(&l_len);
		cChar   *   l_pw2   =pk.ReadString(&l_len2);
		if(!l_cha || l_len > common::conformity::character::name::max_length)
		{
			l_retpk.WriteShort(ERR_PT_INERR);
		}
		else if( strcmp( l_pw2, ply->m_password.c_str() ) != 0 )
		{
			l_retpk.WriteShort(ERR_PT_INVALID_PW2);
		}
		else
		{
			MutexArmor l_lockCha(ply->m_mtxCha);
			char	l_chaidx	=ply->FindIndexByChaName(l_cha);
			if(l_chaidx <0)				//���ʺ�û�������ɫ
			{
				l_retpk.WriteShort(ERR_PT_INVALIDCHA);
			}else if(FindGuildByLeadID(ply->m_chaid[l_chaidx]))						//�Ϸ��Ľ�ɫ
			{
				l_retpk.WriteShort(ERR_PT_ISGLDLEADER);
			}
#ifdef SHUI_JING
			else if( m_tblcrystal->IsHasBuyorSale( ply->m_chaid[l_chaidx], 0)
				|| m_tblcrystal->IsHasBuyorSale( ply->m_chaid[l_chaidx], 1))
			{
				l_retpk.WriteShort(ERR_PT_HASCRYSTALTRADE);
			}
#endif	
			else
			{
				bool bFlag = false;
				int		l_chaid	=ply->m_chaid[l_chaidx];
				char	l_CharIDs[80];l_CharIDs[0]=0;
				char	l_buf[20];
				for(char i=0;i<ply->m_chanum;i++)
				{
					if( i == l_chaidx ) continue;
					//strcat(l_CharIDs,itoa(ply->m_chaid[i],l_buf,10));
					_itoa_s(ply->m_chaid[i], l_buf, sizeof(l_buf), 10);
					strncat_s(l_CharIDs,sizeof(l_CharIDs),l_buf,_TRUNCATE);
					//strcat(l_CharIDs,";");
					strncat_s(l_CharIDs,sizeof(l_CharIDs),";",_TRUNCATE);
				}
				
				MutexArmor l_lockDB(m_mtxDB);
				// �жϽ�ɫ�Ƿ񹫻��Ա������ɾ�������б���Ϣ
				if( m_tblaccounts->begin_tran() )
				{
					if( !m_tblaccounts->UpdateRow(ply->m_acctid,l_CharIDs) || !m_tblcharaters->BackupRow(l_chaid) || !m_tblaccounts->commit_tran() )
					{
						m_tblaccounts->rollback();
					}
					else
					{
						bFlag = true;
					}
				}
				l_lockDB.unlock();

				if( bFlag )
				{
					l_retpk.WriteShort(ERR_SUCCESS);	//ɾ����ɫ�ɹ�����
					ply->m_chanum	--;
					for(;l_chaidx<ply->m_chanum;l_chaidx++)
					{
						ply->m_chaid[l_chaidx]		=ply->m_chaid[l_chaidx+1];
						ply->m_chaname[l_chaidx]	=ply->m_chaname[l_chaidx+1];
						ply->m_motto[l_chaidx]		=ply->m_motto[l_chaidx+1];
						ply->m_icon[l_chaidx]		=ply->m_icon[l_chaidx+1];
						ply->m_guild[l_chaidx]		=ply->m_guild[l_chaidx+1];
					}

					LogLine l_line(g_LogGrpServer);
					/*
					l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]ɾ���˽�ɫ["
						<<l_cha<<"]��\t��ǰ��¼/��Ϸ�����:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)
						<<endln;
                   */
					l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<RES_STRING(GP_GROUPSERVERAPPSERV_CPP_00043)
						<<l_cha<<RES_STRING(GP_GROUPSERVERAPPSERV_CPP_00044)<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)
						<<endln;
				}
				else
				{
					l_retpk.WriteShort(ERR_PT_SERVERBUSY);	//������æµ�����Ժ�
					LogLine l_line(g_LogGrpServer);
					/*
					l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]ɾ����ɫʧ��["
						<<l_cha<<"]��\t��ǰ��¼/��Ϸ�����:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)
						<<endln;
					*/
					l_line<<newln<<"("<<ply->m_clientip<<"):["<<ply->m_acctname<<"]delete char failed["
						<<l_cha<<"]��\t GetTotal/m_curChaNum:"<<m_plylst.GetTotal()<<"/"<<long(m_curChaNum)
						<<endln;
				}
			}
			l_lockCha.unlock();
		}
	}
	return l_retpk;
}

WPacket	GroupServerApp::TP_CREATE_PASSWORD2(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();
	dbc::uShort seq_len;
	const auto		seq			= pk.ReadString(&seq_len);
	std::string strPassword(seq, seq_len);

	if( ply->m_password.length() == 0 && strPassword.length() <= ROLE_MAXSIZE_PASSWORD2 )
	{
		MutexArmor l_lockDB(m_mtxDB);

		if( m_tblaccounts->UpdatePassword( ply->m_acctid, strPassword.c_str() ) )
		{
			ply->m_password = strPassword;
			l_retpk.WriteShort( ERR_SUCCESS );
			LogLine l_line(g_LogErrServer);
			//l_line<<newln<<"�ʻ�:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"���ݿ�����ɹ�:("<<strPassword.c_str()<<")"<<endln;		
			l_line<<newln<<"account:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"database operate success:("<<strPassword.c_str()<<")"<<endln;		
		}
		else
		{
			l_retpk.WriteShort( ERR_PT_SERVERBUSY );
			LogLine l_line(g_LogErrServer);
			//l_line<<newln<<"�ʻ�:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"���ݿ��������:("<<strPassword.c_str()<<")"<<endln;
			l_line<<newln<<"account:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"database operate failed:("<<strPassword.c_str()<<")"<<endln;
		}
	}
	else
	{
		l_retpk.WriteShort( ERR_PT_INVALID_PW2 );
		LogLine l_line(g_LogErrServer);
		//l_line<<newln<<"�ʻ�:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"����Ķ�������:("<<strPassword.c_str()<<")"<<endln;		
		l_line<<newln<<"account:"<<ply->m_acctname<<"ID:"<<ply->m_acctid<<"wrong second password:("<<strPassword.c_str()<<")"<<endln;		
	}
	return l_retpk;
}

WPacket GroupServerApp::TP_UPDATE_PASSWORD2(Player *ply,DataSocket *datasock,RPacket &pk)
{
	WPacket		l_retpk	=GetWPacket();

	uShort old_len, new_len; 
	const auto old_password = pk.ReadString(&old_len);
	const auto new_password = pk.ReadString(&new_len);

	if(ply->m_password == old_password && new_len <= ROLE_MAXSIZE_PASSWORD2)
	{
		MutexArmor l_lockDB(m_mtxDB);

		if( m_tblaccounts->UpdatePassword( ply->m_acctid, new_password) )
		{
			ply->m_password = new_password;
			l_retpk.WriteShort( ERR_SUCCESS );
		}
		else
		{
			l_retpk.WriteShort( ERR_PT_SERVERBUSY );
		}
	}
	else
	{
		l_retpk.WriteShort( ERR_PT_INVALID_PW2 );
	}
	return l_retpk;
}

/*						char *l_str	=strstr(l_look,";");
						if(l_str)	*l_str=0;
						look.sTypeID	=atoi(l_look);
						l_look	=l_str+1;
						l_str	=strstr(l_look,";");
						for(int i=0;(l_str ||*l_look)&&(i<enumEQUIP_NUM);i++)
						{
							if(l_str)	*l_str=0;
							look.chState[i]	=atoi(l_look);
							if(l_str)
							{
								l_look	=l_str+1;
								l_str	=strstr(l_look,";");
							}else
							{
								l_look --;
							}
						}
						for(int i=0;(l_str ||*l_look)&&(i<enumEQUIP_NUM);i++)
						{
							if(l_str)	*l_str=0;
							look.sLink[i]	=atoi(l_look);
							if(l_str)
							{
								l_look	=l_str+1;
								l_str	=strstr(l_look,";");
							}else
							{
								l_look --;
							}
						}
*/
/*							char	l_tmpbuf[20];
							strcpy(l_look,itoa(look->sTypeID,l_tmpbuf,10));
							for(short i=0;i<enumEQUIP_NUM;i++)
							{
								strcat(l_look,";");
								strcat(l_look,itoa(look->chState[i],l_tmpbuf,10));
							}
							for(short i=0;i<enumEQUIP_NUM;i++)
							{
								strcat(l_look,";");
								strcat(l_look,itoa(look->sLink[i],l_tmpbuf,10));
							}
*/


void GroupServerApp::MP_GARNER2_UPDATE(Player *ply,DataSocket *datasock,RPacket &pk)
{
	ORDERINFO orderinfo;
	//SYSTEMTIME st;time_t
	//GetLocalTime( &st);
	//time_t tt;
	//time(&tt);
	orderinfo .nid = pk.ReadLong();
	string strChaName = pk.ReadString();
	orderinfo.nlev = pk.ReadLong();
	string strjob = pk.ReadString();
	short sFightpoint = pk.ReadShort();

	if(strChaName.length() > common::conformity::character::name::max_length)
	{
		LogLine	l_line(g_LogGarner2);
		//l_line<<newln<<"���������������ݳ���";
		l_line<<newln<<"order data exception";
		return;
	}
	//strcpy(orderinfo.strname,strChaName.c_str());
	strncpy_s(orderinfo.strname,sizeof(orderinfo.strname),strChaName.c_str(),_TRUNCATE);

	if(strjob.length() > 100)
	{
		LogLine	l_line(g_LogGarner2);
		//l_line<<newln<<"���������������ݳ���";
		l_line<<newln<<"order data exception";
		return;
	}
	//strcpy(orderinfo.strjob,strjob.c_str());
	strncpy_s(orderinfo.strjob,sizeof(orderinfo.strjob),strjob.c_str(),_TRUNCATE);
	orderinfo.nfightpoint = (long)sFightpoint; 

	MutexArmor l_lockDB(m_mtxDB);
	m_tbLparam->UpdateOrder(orderinfo);
	CP_GARNER2_GETORDER(ply,datasock,pk);
}

void GroupServerApp::CP_GARNER2_GETORDER(Player *ply,DataSocket *datasock,RPacket &pk)
{
		WPacket l_wpk = g_gpsvr->GetWPacket();
		ORDERINFO * porder;
		l_wpk.WriteCmd(CMD_PC_GARNER2_ORDER);
		for(int i = 0;i<MAXORDERNUM;i++)
		{
			porder = m_tbLparam->GetOrderData(i);
			l_wpk.WriteString(porder->strname);
			l_wpk.WriteLong(porder->nlev);
			l_wpk.WriteString(porder->strjob);
			l_wpk.WriteLong(porder->nfightpoint);
		}
		g_gpsvr->SendToClient(ply,l_wpk);
	
}
//Add by sunny.sun 20090828
void GroupServerApp::MP_GM_BANACCOUNT(Player *ply,DataSocket *datasock,RPacket &pk)
{
		string actName = pk.ReadString();
		WPacket l_wpk = g_gpsvr->GetWPacket();
		l_wpk.WriteCmd(CMD_PA_GMBANACCOUNT);
		l_wpk.WriteString(actName.c_str());
		g_gpsvr->SendData(g_gpsvr->m_acctsock,l_wpk);
}